// Vertex shader
const vertexShaderSource = `
attribute vec3 vertex;
attribute vec3 normal;
attribute vec2 textureCoord;    
uniform mat4 WorldInverseTranspose;
uniform mat4 ModelViewProjectionMatrix;
uniform vec3 pointPosition;

varying vec3 vertexVarying;
varying vec3 normalVarying;
varying vec2 v_texcoord;
varying vec4 pointColor;

void main() {
    normalVarying = (WorldInverseTranspose * vec4(normalize(normal), 0.0)).xyz;

    pointColor = vec4(0.0, 0.0, 0.0, 0.0);
    if(distance(pointPosition, vertex) < 0.1){
        pointColor.x = 1.0;
        pointColor.y = -1.0;
        pointColor.z = -1.0;
    }

    vec4 worldVertex = ModelViewProjectionMatrix * vec4(vertex,1.0);
    vertexVarying = worldVertex.xyz;
    v_texcoord = textureCoord;
    gl_Position = worldVertex;
}`;


// Fragment shader
const fragmentShaderSource = `
#ifdef GL_FRAGMENT_PRECISION_HIGH
   precision highp float;
#else
   precision mediump float;
#endif

uniform vec3 LightPosition;
uniform vec3 CamWorldPosition;

uniform vec3 lightAmbientColor;
uniform vec3 lightDiffuseColor;
uniform vec3 lightSpecularColor;

uniform vec3 matAmbientColor;
uniform vec3 matDiffuseColor;
uniform vec3 matSpecularColor;
uniform float matShininess;

float attenuationConstant = 1.0;
float attenuationLiner = 0.045;
float attenuationQuadratic = 0.0075;

uniform vec3 pointPosition;
uniform vec2 scalePoint;
uniform float textureScale;

varying vec3 vertexVarying;
varying vec3 normalVarying;
uniform sampler2D tmu;
varying vec2 v_texcoord;
varying vec4 pointColor;
 
varying vec4 color;
mat3 getScaleMatrix(float scale, vec2 center) {
    return mat3(
        scale, 0.0, 0.0,
        0.0, scale, 0.0,
        center.x * (1.0 - scale), center.y * (1.0 - scale), 1.0
    );
}

void main() {
    // Calculate Lambertian reflection
    vec3 N = normalize(normalVarying);
    vec3 L = normalize(vertexVarying - LightPosition);
    float lambertian = max(0.0, dot(N, L));

    // Calculate specular reflection
    vec3 reflectLighDir = normalize(reflect(L, N));
    vec3 dirToCamera = normalize(CamWorldPosition - vertexVarying);
    vec3 ambient = matAmbientColor * lightAmbientColor;

    // Apply Lambertian reflection
    vec3 diffuse = matDiffuseColor * lightDiffuseColor * lambertian;

    // Apply specular reflection
    vec3 specular = matSpecularColor * lightSpecularColor * pow(max(0.0, dot(dirToCamera, reflectLighDir)), matShininess);

    // Calculate distance-based attenuation
    float distance = length(vertexVarying - LightPosition);
    float attenuation = 1.0 / (attenuationConstant + attenuationLiner * distance + attenuationQuadratic * (distance * distance));

    // Create a scaling matrix
    mat3 scaleMatrix = getScaleMatrix(textureScale, scalePoint);

    // Apply scaling to UV coordinates
    vec3 scaledUV = vec3(v_texcoord, 1.0) * scaleMatrix;

    // Sample the texture and apply lighting calculations
    gl_FragColor = texture2D(tmu, scaledUV.xy) * vec4(ambient * attenuation + diffuse * attenuation + specular * attenuation, 1) + pointColor;
}`;